// 记录(Record)/提交(Submission)模型，用于用于在线评测系统（Online Judge）的提交记录管理代码
import { pick, sum } from 'lodash';
import moment from 'moment-timezone';
import {
    Filter, FindOptions, MatchKeysAndValues,
    ObjectId, OnlyFieldsOfType, PushOperator, UpdateFilter,
} from 'mongodb';
import { ProblemConfigFile } from '@hydrooj/common';
import { Context } from '../context';
import { ProblemNotFoundError } from '../error';
import { JudgeMeta, RecordDoc } from '../interface';
import db from '../service/db';
import { MaybeArray, NumberKeys } from '../typeutils';
import { ArgMethod, buildProjection, Time } from '../utils';
import { STATUS } from './builtin';
import DomainModel from './domain';
import problem from './problem';
import SystemModel from './system';
import task from './task';

export default class RecordModel { // 核心类
    static coll = db.collection('record'); // 主记录集合
    static collStat = db.collection('record.stat'); // 统计信息集合（用于排行榜等）
    static collHistory = db.collection('record.history'); // 历史记录集合
    static PROJECTION_LIST: (keyof RecordDoc)[] = [ // 查询时返回的字段列表，包含常规字段和新增的绩效相关字段
        '_id', 'score', 'time', 'memory', 'lang',
        'uid', 'pid', 'rejudged', 'progress', 'domainId',
        'contest', 'judger', 'judgeAt', 'status', 'source',
        'files', 'hackTarget',
    ];

    static STAT_QUERY = {
        time: [{ time: -1 }, { time: 1 }],
        memory: [{ memory: -1 }, { memory: 1 }],
        length: [{ length: -1 }, { length: 1 }],
        date: [{ _id: -1 }, { _id: 1 }],
    };

    // 特数记录类型
    static RECORD_PRETEST = new ObjectId('000000000000000000000000'); // // 预测试记录
    static RECORD_GENERATE = new ObjectId('000000000000000000000001'); // // 题目生成记录

    // 计算提交优先级
    static async submissionPriority(uid: number, base: number = 0) {
        //获取用户最近30分钟的提交记录
        const timeRecent = await RecordModel.coll
            .find({ _id: { $gte: Time.getObjectID(moment().add(-30, 'minutes')) }, uid, rejudged: { $ne: true } })
            .project({ time: 1, status: 1 }).toArray();
            //计算正在等待评测的记录数量
        const pending = timeRecent.filter((i) => [
            STATUS.STATUS_WAITING, STATUS.STATUS_FETCHED, STATUS.STATUS_COMPILING, STATUS.STATUS_JUDGING,
        ].includes(i.status)).length;
        //基于基础优先级、等待数量和耗时计算最终优先级
        return Math.max(base - 10000, base - (pending * 1000 + 1) * (sum(timeRecent.map((i) => i.time || 0)) / 10000 + 1));
    }

    static async get(_id: ObjectId): Promise<RecordDoc | null>;
    static async get(domainId: string, _id: ObjectId): Promise<RecordDoc | null>;
    static async get(arg0: string | ObjectId, arg1?: any) {
        const _id = arg1 || arg0;
        const domainId = arg1 ? arg0 : null;
        const res = await RecordModel.coll.findOne({ _id });
        if (!res) return null;
        if (res.domainId === (domainId || res.domainId)) return res;
        return null;
    }

    @ArgMethod
    static async stat(domainId?: string) { // 获取系统统计信息（5分钟、1小时、1天等时间段的提交数量）
        // INFO:
        // using .count() for a much better performace
        // @see https://www.mongodb.com/docs/manual/reference/command/count/
        const [d5min, d1h, day, week, month, year, total] = await Promise.all([
            RecordModel.coll.find({ _id: { $gte: Time.getObjectID(moment().add(-5, 'minutes')) }, ...domainId ? { domainId } : {} }).count(),
            RecordModel.coll.find({ _id: { $gte: Time.getObjectID(moment().add(-1, 'hour')) }, ...domainId ? { domainId } : {} }).count(),
            RecordModel.coll.find({ _id: { $gte: Time.getObjectID(moment().add(-1, 'day')) }, ...domainId ? { domainId } : {} }).count(),
            RecordModel.coll.find({ _id: { $gte: Time.getObjectID(moment().add(-1, 'week')) }, ...domainId ? { domainId } : {} }).count(),
            RecordModel.coll.find({ _id: { $gte: Time.getObjectID(moment().add(-1, 'month')) }, ...domainId ? { domainId } : {} }).count(),
            RecordModel.coll.find({ _id: { $gte: Time.getObjectID(moment().add(-1, 'year')) }, ...domainId ? { domainId } : {} }).count(),
            RecordModel.coll.find(domainId ? { domainId } : {}).count(),
        ]);
        return {
            d5min, d1h, day, week, month, year, total,
        };
    }

    static async judge( // 将提交加入评测队列
            // 1. 验证提交记录和题目存在性
                // 2. 如果是引用题目，获取原题目信息
    // 3. 确定评测类型（普通评测、远程评测、题目生成）
    // 4. 创建评测任务并添加到任务队列
        domainId: string, rids: MaybeArray<ObjectId> | RecordDoc, priority = 0,
        config: ProblemConfigFile = {}, meta: Partial<JudgeMeta> = {},
    ) {
        let rdocs: RecordDoc[];
        const _rids = rids instanceof Array ? rids
            : (rids instanceof ObjectId) ? [rids]
                : [rids._id];
        if (!_rids.length) return null;
        if (rids instanceof Array || rids instanceof ObjectId || ObjectId.isValid(rids.toString())) {
            rdocs = await RecordModel.getMulti(domainId, { _id: { $in: _rids } }, { readPreference: 'primary' }).toArray();
        } else rdocs = [rids];
        if (!rdocs.length) return null;
        let source = `${domainId}/${rdocs[0].pid}`;
        let [pdoc] = await Promise.all([
            problem.get(domainId, rdocs[0].pid),
            task.deleteMany({ rid: { $in: _rids } }),
        ]);
        if (!pdoc) throw new ProblemNotFoundError(domainId, rdocs[0].pid);
        if (pdoc.reference) {
            pdoc = await problem.get(pdoc.reference.domainId, pdoc.reference.pid);
            if (!pdoc) throw new ProblemNotFoundError(domainId, rdocs[0].pid);
            source = `${pdoc.domainId}/${pdoc.docId}`;
        }
        meta = { ...meta, problemOwner: pdoc.owner };
        const ddoc = await DomainModel.get(pdoc.domainId);
        return await task.addMany(rdocs.map((rdoc) => {
            let type = 'judge';
            if (typeof pdoc.config === 'string') throw new Error(pdoc.config);
            if (pdoc.config.type === 'remote_judge' && rdoc.contest?.toHexString() !== '0'.repeat(24)) type = 'remotejudge';
            else if (meta?.type === 'generate') type = 'generate';
            return ({
                ...rdoc,
                ...(pdoc.config as any), // TODO deprecate this
                priority,
                type,
                rid: rdoc._id,
                domainId,
                config: {
                    ...(pdoc.config as any),
                    ...config,
                },
                data: pdoc.data,
                source,
                trusted: ddoc.isTrusted,
                meta,
            } as any);
        }));
    }

    static async add( // 创建新的提交记录
        domainId: string, pid: number, uid: number,
        lang: string, code: string, addTask: boolean,
        args: {
            contest?: ObjectId;
            input?: string;
            files?: Record<string, string>;
            hackTarget?: ObjectId;
            type: 'judge' | 'rejudge' | 'pretest' | 'hack' | 'generate';
        } = { type: 'judge' },
    ) {
        const data: RecordDoc = {
            status: STATUS.STATUS_WAITING,   // 初始状态为等待评测
            _id: new ObjectId(), // 生成唯一ID
            uid,
            code,
            lang,
            pid,
            domainId,
            score: 0,
            time: 0,
            memory: 0,
            judgeTexts: [],
            compilerTexts: [],
            testCases: [],
            judger: null,
            judgeAt: null,
            rejudged: false,
        };
        let isContest = !!args.contest;
        if (args.contest) data.contest = args.contest;
        if (args.files) data.files = args.files;
        if (args.hackTarget) data.hackTarget = args.hackTarget;
        if (args.type === 'rejudge') {
            args.type = 'judge';
            data.rejudged = true;
        } else if (args.type === 'pretest') {
            data.input = args.input || '';
            isContest = false;
            data.contest = RecordModel.RECORD_PRETEST;
        } else if (args.type === 'generate') {
            data.contest = RecordModel.RECORD_GENERATE;
        }
        const res = await RecordModel.coll.insertOne(data);
        bus.broadcast('record/change', data);
        if (addTask) {
            const priority = await RecordModel.submissionPriority(uid, args.type === 'pretest' ? -20 : (isContest ? 50 : 0));
            await RecordModel.judge(domainId, data, priority, isContest ? { detail: false } : {}, {
                type: args.type,
                rejudge: data.rejudged,
            });
        }
        return res.insertedId;
    }

    // 获取多条记录
    static getMulti(domainId: string, query: any, options?: FindOptions) {
        if (domainId) query = { domainId, ...query };
        return RecordModel.coll.find(query, options);
    }

    static getMultiStat(domainId: string, query: any, sortBy: any = { _id: -1 }) {
        return RecordModel.collStat.find({ domainId, ...query }).sort(sortBy);
    }

    //  更新记录信息
    static async update(
        domainId: string, _id: MaybeArray<ObjectId>,
        $set?: MatchKeysAndValues<RecordDoc>,
        $push?: PushOperator<RecordDoc>,
        $unset?: OnlyFieldsOfType<RecordDoc, any, true | '' | 1>,
        $inc?: Partial<Record<NumberKeys<RecordDoc>, number>>,
    ): Promise<RecordDoc | null> {
        const $update: UpdateFilter<RecordDoc> = {};
        if ($set && Object.keys($set).length) $update.$set = $set;
        if ($push && Object.keys($push).length) $update.$push = $push;
        if ($unset && Object.keys($unset).length) $update.$unset = $unset;
        if ($inc && Object.keys($inc).length) $update.$inc = $inc;
        if (_id instanceof Array) {
            await RecordModel.coll.updateMany({ _id: { $in: _id }, domainId }, $update);
            return null;
        }
        if (Object.keys($update).length) {
            return await RecordModel.coll.findOneAndUpdate(
                { _id, domainId },
                $update,
                { returnDocument: 'after' },
            );
        }
        return await RecordModel.coll.findOne({ _id }, { readPreference: 'primary' });
    }

    // 批量更新
    static async updateMulti(
        domainId: string, $match: Filter<RecordDoc>,
        $set?: MatchKeysAndValues<RecordDoc>,
        $push?: PushOperator<RecordDoc>,
        $unset?: OnlyFieldsOfType<RecordDoc, any, true | '' | 1>,
    ) {
        const $update: UpdateFilter<RecordDoc> = {};
        if ($set && Object.keys($set).length) $update.$set = $set;
        if ($push && Object.keys($push).length) $update.$push = $push;
        if ($unset && Object.keys($unset).length) $update.$unset = $unset;
        const res = await RecordModel.coll.updateMany({ domainId, ...$match }, $update);
        return res.modifiedCount;
    }

    // 重置记录状态（用于重判）
    static async reset(domainId: string, rid: MaybeArray<ObjectId>, isRejudge: boolean) {
        const rids = Array.isArray(rid) ? rid : [rid];
        const upd: any = {
            score: 0,
            status: STATUS.STATUS_WAITING,
            time: 0,
            memory: 0,
            testCases: [],
            subtasks: {},
            judgeTexts: [],
            compilerTexts: [],
            judgeAt: null,
            judger: null,
        };
        if (isRejudge) upd.rejudged = true;
        const [rdocs] = await Promise.all([
            RecordModel.coll.find({ _id: { $in: rids }, judgeAt: { $exists: true, $ne: null } }).toArray(),
            RecordModel.collStat.deleteMany({ _id: { $in: rids } }),
            task.deleteMany({ rid: { $in: rids } }),
        ]);
        if (rdocs.length) {
            await RecordModel.collHistory.insertMany(rdocs.map((rdoc) => ({
                ...pick(rdoc, [
                    'compilerTexts', 'judgeTexts', 'testCases', 'subtasks',
                    'score', 'time', 'memory', 'status', 'judgeAt', 'judger',
                ]),
                rid: rdoc._id,
                _id: new ObjectId(),
            })));
        }
        return RecordModel.update(domainId, rid, upd);
    }

    static count(domainId: string, query: any) { // 统计记录数量
        return RecordModel.coll.countDocuments({ domainId, ...query });
    }

    static async getList( // 批量获取记录列表
        domainId: string, rids: ObjectId[], fields?: (keyof RecordDoc)[],
    ): Promise<Record<string, Partial<RecordDoc>>> {
        const r: Record<string, RecordDoc> = {};
        rids = Array.from(new Set(rids));
        let cursor = RecordModel.coll.find({ domainId, _id: { $in: rids } });
        if (fields) cursor = cursor.project(buildProjection(fields));
        const rdocs = await cursor.toArray();
        for (const rdoc of rdocs) r[rdoc._id.toHexString()] = rdoc;
        return r;
    }
}

// 主要负责：模型的生命周期管理和事件处理
export async function apply(ctx: Context) {
    // 事件监听器注册
    ctx.on('problem/delete', (domainId, docId) => Promise.all([
        RecordModel.coll.deleteMany({ domainId, pid: docId }),
        RecordModel.collStat.deleteMany({ domainId, pid: docId }),
    ]));
    // 当题目被删除时，自动删除这个题目的所有提交记录和统计信息
    ctx.on('domain/delete', (domainId) => RecordModel.coll.deleteMany({ domainId }));
    // 当域被删除时，删除这个域内所有的提交记录
    ctx.on('record/judge', async (rdoc, updated) => {
        if (rdoc.status === STATUS.STATUS_ACCEPTED && updated) {
            // 如果系统是unique模式，删除同一用户同一题目的旧记录
            if (SystemModel.get('record.statMode') === 'unique') {
                await RecordModel.collStat.deleteMany({
                    _id: { $ne: rdoc._id },
                    uid: rdoc.uid,
                    pid: rdoc.pid,
                    domainId: rdoc.domainId,
                });
            }
            // 更新统计集合中的最佳纪录
            await RecordModel.collStat.updateOne({
                _id: rdoc._id,
            }, {
                $set: {
                    domainId: rdoc.domainId,
                    pid: rdoc.pid,
                    uid: rdoc.uid,
                    time: rdoc.time,
                    memory: rdoc.memory,
                    length: rdoc.code?.length || 0,
                    lang: rdoc.lang,
                },
            }, { upsert: true });
        }
    });
    // 创建数据库索引
    await Promise.all([
        db.ensureIndexes( // 主记录集合索引
            RecordModel.coll,
            { key: { domainId: 1, pid: 1 }, name: 'delete' }, // 按域和题目快速删除
            { key: { domainId: 1, contest: 1, _id: -1 }, name: 'basic' }, // 基础查询（域+比赛+时间倒序）
            { key: { domainId: 1, contest: 1, uid: 1, _id: -1 }, name: 'withUser' }, // 用户相关的查询
            { key: { domainId: 1, contest: 1, pid: 1, _id: -1 }, name: 'withProblem' }, // 题目相关的查询
            { key: { domainId: 1, contest: 1, pid: 1, uid: 1, _id: -1 }, name: 'withUserAndProblem' }, // 用户和题目组合查询 
            { key: { domainId: 1, contest: 1, status: 1, _id: -1 }, name: 'withStatus' }, // 按状态筛选
        ),
        db.ensureIndexes( // 统计集合索引
            RecordModel.collStat, // 按时间、内存、代码长度排序的排行榜查询
            { key: { domainId: 1, pid: 1, uid: 1, _id: -1 }, name: 'basic' },
            { key: { domainId: 1, pid: 1, uid: 1, time: 1 }, name: 'time' },
            { key: { domainId: 1, pid: 1, uid: 1, memory: 1 }, name: 'memory' },
            { key: { domainId: 1, pid: 1, uid: 1, length: 1 }, name: 'length' },
        ),
        db.ensureIndexes( // 历史记录集合索引
            RecordModel.collHistory, // 按记录ID快速查询历史版本 
            { key: { rid: 1, _id: -1 }, name: 'basic' },
        ),
    ]);
}
// 全局注册
global.Hydro.model.record = RecordModel; // 将RecordModel 注册到全局的 Hydro 模型中，整个应用中应用。
